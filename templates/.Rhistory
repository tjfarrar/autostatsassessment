# Standardised version of PDF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# PDF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Support of random variable in LaTeX format
supportlatex <- paste0(support[1], "\\\\le x \\\\le ", support[2])
numerk <- substr(fractions(k), start = 1, stop = regexpr("/", fractions(k)) - 1)
denomk <- substr(fractions(k), start = regexpr("/", fractions(k)) + 1, stop = nchar(as.character(fractions(k))))
# Put PDF multiplied by x into symPy syntax
integrand_sympy <- paste0("Rational(", numerk, ", ", denomk, ") * x * (",
deparse(body(f)), ")") %>%
gsub(pattern = "\\^", replacement = "**") %>%
gsub(pattern = "exponent", replacement = exponent) %>%
gsub(pattern = "const", replacement = const)
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympynlatex(double = FALSE)
# antider_latex <- paste0("latex(integrate(", mysymcharmom1, "))") %>% as.character.Sym %>% sympy %>% gsub(pattern = "\\$", replacement = "") %>% gsub(pattern = "\\\\", replacement = "\\\\\\\\")
# Numerically calculate expectation
expval <- integrate(function(x) x * fstd(x), lower = support[1], upper = support[2])$value
# Express numerical final answer in LaTeX format
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
AnsHi <- paste0("L1.subs(x, ", support[2], ")") %>%
sympy
AnsLo <- paste0("L1.subs(x, ", support[1], ")") %>%
sympy
AnsHi_latex <- paste0("L1.subs(x, ", support[2], ")") %>%
sympynlatex(double = FALSE)
AnsLo_latex <- paste0("L1.subs(x, ", support[1], ")") %>%
sympynlatex(double = FALSE)
Ans <- eval(parse(text = AnsHi)) - eval(parse(text = AnsLo))
# Checking for errors
if (!berryFunctions::almost.equal(Ans, expval)) {
stop(paste0("Expectation answers do not match: f =", deparse(body(f)),
"; support limits =[", support[1], ", ", support[2], "]; sympy answer: ",
Ans, "; integrate answer: ", expval, "; Case =", Case))
}
}
f
flatex
integrand_sympy
antider_eval_sympy
supportlatex
14/45
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympynlatex(double = FALSE)
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympy
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympy
antider_latex <- paste0("integrate(", integrand_sympy, ")") %>%
sympynlatex(double = FALSE)
antider_latex
expval <- integrate(function(x) x * fstd(x), lower = support[1], upper = support[2])$value
# Express numerical final answer in LaTeX format
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
expval
expvallatex
AnsHi <- paste0("L1.subs(x, ", support[2], ")") %>%
sympy
AnsLo <- paste0("L1.subs(x, ", support[1], ")") %>%
sympy
AnsHi_latex <- paste0("L1.subs(x, ", support[2], ")") %>%
sympynlatex(double = FALSE)
AnsLo_latex <- paste0("L1.subs(x, ", support[1], ")") %>%
sympynlatex(double = FALSE)
Ans <- eval(parse(text = AnsHi)) - eval(parse(text = AnsLo))
Ans
test_questions_Rmd <- list("upload_expectation.Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(cases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
test_questions_Rmd <- list("upload_expectation.Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(cases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
source("~/.active-rstudio-document", echo = TRUE)
test_questions_Rmd <- list("upload_expectation.Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(cases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
Case
# rSymPy package must be loaded
# mathstatsfunctions.R must have been sourced
Var("x")
# This code ensures that versions of the question toggle
#  between discrete and continuous
if(!exists("cases") || length(cases) < 1) {
cases <- 1:2
}
Case <- cases[1]
cases <- cases[-1]
if (Case == 1) { # Discrete
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- 1
supportmax <- sample(3:5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability mass function
exponent <- sample(setdiff(-3:3, 0), 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
mysum <- sum(vapply(support, f, 0))
# Constant of summation
k <- 1 / mysum
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Standardised version of PMF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# Constant of summation in LaTeX format
klatex <- fractions(1 / mysum, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
if (klatex == "0") stop(paste0("klatex is 0; exponent = ", exponent, "; const = ", const, "; mysum = ", mysum, "; k = ", k))
# Support of random variable in LaTeX format
supportlatex <- paste0("x = ", paste(support, collapse = ", "))
# PMF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Calculate E(X) numerically
expval <- sum(vapply(support, function(x) x * fstd(x), 0))
# Convert E(X) final answer to LaTeX
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
} else if (Case == 2) { # Continuous
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- sample(0:1, 1)
supportmax <- sample((supportmin + 1):5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability density function
exponent <- sample(1:4, 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
myint <- integrate(f = f, lower = support[1], upper = support[2])$value
# Constant of integration
k <- 1 / myint
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Constant of integration in LaTeX format
klatex <- fractions(1 / myint, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
# Standardised version of PDF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# PDF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Support of random variable in LaTeX format
supportlatex <- paste0(support[1], "\\le x \\le ", support[2])
numerk <- substr(fractions(k), start = 1, stop = regexpr("/", fractions(k)) - 1)
denomk <- substr(fractions(k), start = regexpr("/", fractions(k)) + 1, stop = nchar(as.character(fractions(k))))
# Put PDF multiplied by x into symPy syntax
integrand_sympy <- paste0("Rational(", numerk, ", ", denomk, ") * x * (",
deparse(body(f)), ")") %>%
gsub(pattern = "\\^", replacement = "**") %>%
gsub(pattern = "exponent", replacement = exponent) %>%
gsub(pattern = "const", replacement = const)
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympy
antider_latex <- paste0("integrate(", integrand_sympy, ")") %>%
sympynlatex(double = FALSE)
# Numerically calculate expectation
expval <- integrate(function(x) x * fstd(x), lower = support[1], upper = support[2])$value
# Express numerical final answer in LaTeX format
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
AnsHi <- paste0("L1.subs(x, ", support[2], ")") %>%
sympy
AnsLo <- paste0("L1.subs(x, ", support[1], ")") %>%
sympy
AnsHi_latex <- paste0("L1.subs(x, ", support[2], ")") %>%
sympynlatex(double = FALSE)
AnsLo_latex <- paste0("L1.subs(x, ", support[1], ")") %>%
sympynlatex(double = FALSE)
Ans <- eval(parse(text = AnsHi)) - eval(parse(text = AnsLo))
# Checking for errors
if (!berryFunctions::almost.equal(Ans, expval)) {
stop(paste0("Expectation answers do not match: f =", deparse(body(f)),
"; support limits =[", support[1], ", ", support[2], "]; sympy answer: ",
Ans, "; integrate answer: ", expval, "; Case =", Case))
}
}
Case
supportlatex
# rSymPy package must be loaded
# mathstatsfunctions.R must have been sourced
Var("x")
# This code ensures that versions of the question toggle
#  between discrete and continuous
if(!exists("cases") || length(cases) < 1) {
cases <- 1:2
}
Case <- cases[1]
cases <- cases[-1]
if (Case == 1) { # Discrete
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- 1
supportmax <- sample(3:5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability mass function
exponent <- sample(setdiff(-3:3, 0), 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
mysum <- sum(vapply(support, f, 0))
# Constant of summation
k <- 1 / mysum
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Standardised version of PMF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# Constant of summation in LaTeX format
klatex <- fractions(1 / mysum, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
if (klatex == "0") stop(paste0("klatex is 0; exponent = ", exponent, "; const = ", const, "; mysum = ", mysum, "; k = ", k))
# Support of random variable in LaTeX format
supportlatex <- paste0("x = ", paste(support, collapse = ", "))
# PMF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Calculate E(X) numerically
expval <- sum(vapply(support, function(x) x * fstd(x), 0))
# Convert E(X) final answer to LaTeX
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
} else if (Case == 2) { # Continuous
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- sample(0:1, 1)
supportmax <- sample((supportmin + 1):5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability density function
exponent <- sample(1:4, 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
myint <- integrate(f = f, lower = support[1], upper = support[2])$value
# Constant of integration
k <- 1 / myint
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Constant of integration in LaTeX format
klatex <- fractions(1 / myint, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
# Standardised version of PDF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# PDF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Support of random variable in LaTeX format
supportlatex <- paste0(support[1], "\\le x \\le ", support[2])
numerk <- substr(fractions(k), start = 1, stop = regexpr("/", fractions(k)) - 1)
denomk <- substr(fractions(k), start = regexpr("/", fractions(k)) + 1, stop = nchar(as.character(fractions(k))))
# Put PDF multiplied by x into symPy syntax
integrand_sympy <- paste0("Rational(", numerk, ", ", denomk, ") * x * (",
deparse(body(f)), ")") %>%
gsub(pattern = "\\^", replacement = "**") %>%
gsub(pattern = "exponent", replacement = exponent) %>%
gsub(pattern = "const", replacement = const)
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympy
antider_latex <- paste0("integrate(", integrand_sympy, ")") %>%
sympynlatex(double = FALSE)
# Numerically calculate expectation
expval <- integrate(function(x) x * fstd(x), lower = support[1], upper = support[2])$value
# Express numerical final answer in LaTeX format
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
AnsHi <- paste0("L1.subs(x, ", support[2], ")") %>%
sympy
AnsLo <- paste0("L1.subs(x, ", support[1], ")") %>%
sympy
AnsHi_latex <- paste0("L1.subs(x, ", support[2], ")") %>%
sympynlatex(double = FALSE)
AnsLo_latex <- paste0("L1.subs(x, ", support[1], ")") %>%
sympynlatex(double = FALSE)
Ans <- eval(parse(text = AnsHi)) - eval(parse(text = AnsLo))
# Checking for errors
if (!berryFunctions::almost.equal(Ans, expval)) {
stop(paste0("Expectation answers do not match: f =", deparse(body(f)),
"; support limits =[", support[1], ", ", support[2], "]; sympy answer: ",
Ans, "; integrate answer: ", expval, "; Case =", Case))
}
}
Case
supportlatex
test_questions_Rmd <- list("upload_expectation.Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(cases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
test_questions_Rmd <- list("upload_expectation.Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(thecases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
test_questions_Rmd <- list("upload_expectation.Rnw")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(thecases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(thecases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
warnings()
# It is VERY important to set the seed here
set.seed(myseed)
# This resets the toggle variable for upload_expectation to
#  toggle between discrete and continuous questions
rm(thecases)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
# It is VERY important to set the seed here
set.seed(myseed)
# Generate an HTML version of the test for preview purposes
exams2html(file = test_questions_Rmd, n = maxn,
mathjax = TRUE, converter = "pandoc-mathjax",
solution = TRUE,
name = "Example_Test_1_", dir = "ExampleTest1_Rmd")
set.seed(myseed)
# rSymPy package must be loaded
# mathstatsfunctions.R must have been sourced
Var("x")
rvtype <- sample(c("discrete", "continuous"), 1)
if (rvtype == "discrete") {
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- 1
supportmax <- sample(3:5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability mass function
exponent <- sample(setdiff(-3:3, 0), 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
mysum <- sum(vapply(support, f, 0))
# Constant of summation
k <- 1 / mysum
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Standardised version of PMF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# Constant of summation in LaTeX format
klatex <- fractions(1 / mysum, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
if (klatex == "0") stop(paste0("klatex is 0; exponent = ", exponent, "; const = ", const, "; mysum = ", mysum, "; k = ", k))
# Support of random variable in LaTeX format
supportlatex <- paste0("x = ", paste(support, collapse = ", "))
# PMF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Calculate E(X) numerically
expval <- sum(vapply(support, function(x) x * fstd(x), 0))
# Convert E(X) final answer to LaTeX
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = TRUE)
} else if (rvtype == "continuous") {
toolargedenom <- TRUE
# Loop ensures that we don't get a large, ugly denominator
#  in the constant k
while (toolargedenom) {
# Generate support of the random variable
supportmin <- sample(0:1, 1)
supportmax <- sample((supportmin + 1):5, 1)
support <- supportmin:supportmax
# Generate parameters to be used in probability density function
exponent <- sample(1:4, 1)
const <- sample(1:5, 1)
f <- function(x) x ^ exponent + const
myint <- integrate(f = f, lower = support[1], upper = support[2])$value
# Constant of integration
k <- 1 / myint
denom <- as.character(fractions(k, max.denominator = 1e6)) %>% substr(start = regexpr("/", .) + 1, stop = nchar(.))
if (nchar(denom) <= 3) toolargedenom <- FALSE
}
# Constant of integration in LaTeX format
klatex <- fractions(1 / myint, max.denominator = 1e6) %>%
frac2latex(double = FALSE)
# Standardised version of PDF as an R function
fstd <- function(x) k * (x ^ exponent + const)
# PDF in LaTeX format
flatex <- ifelse(exponent == 1,
paste0(klatex, " (x + ", const, ")"),
paste0(klatex, " (x ^ {", exponent, "} + ", const, ")"))
# Support of random variable in LaTeX format
supportlatex <- paste0(support[1], "\\le x \\le ", support[2])
numerk <- substr(fractions(k), start = 1, stop = regexpr("/", fractions(k)) - 1)
denomk <- substr(fractions(k), start = regexpr("/", fractions(k)) + 1, stop = nchar(as.character(fractions(k))))
# Put PDF multiplied by x into symPy syntax
integrand_sympy <- paste0("Rational(", numerk, ", ", denomk, ") * x * (",
deparse(body(f)), ")") %>%
gsub(pattern = "\\^", replacement = "**") %>%
gsub(pattern = "exponent", replacement = exponent) %>%
gsub(pattern = "const", replacement = const)
antider_eval_sympy <- paste0("L1 = integrate(", integrand_sympy, ", x)") %>% sympy
antider_latex <- paste0("integrate(", integrand_sympy, ")") %>%
sympynlatex(double = FALSE)
# Numerically calculate expectation
expval <- integrate(function(x) x * fstd(x), lower = support[1], upper = support[2])$value
# Express numerical final answer in LaTeX format
expvallatex <- fractions(expval, max.denominator = 1e6) %>%
frac2latex(double = TRUE)
AnsHi <- paste0("L1.subs(x, ", support[2], ")") %>%
sympy
AnsLo <- paste0("L1.subs(x, ", support[1], ")") %>%
sympy
AnsHi_latex <- paste0("L1.subs(x, ", support[2], ")") %>%
sympynlatex(double = FALSE)
AnsLo_latex <- paste0("L1.subs(x, ", support[1], ")") %>%
sympynlatex(double = FALSE)
Ans <- eval(parse(text = AnsHi)) - eval(parse(text = AnsLo))
# Checking for errors
if (!berryFunctions::almost.equal(Ans, expval)) {
stop(paste0("Expectation answers do not match: f =", deparse(body(f)),
"; support limits =[", support[1], ", ", support[2], "]; sympy answer: ",
Ans, "; integrate answer: ", expval, "; rvtype =", rvtype))
}
}
rvtype
expvallatex
body(frac2latex)
frac2latex <- function(x, double = TRUE) {
x <- as.character(x)
if (regexpr("/", x[1]) == -1) {
x
} else {
numerator <- substr(x, start = 1, stop = regexpr("/", x) - 1)
denominator <- substr(x, start = regexpr("/", x) + 1, stop = nchar(x))
if (double) {
paste0("\\\\frac{", numerator, "}{", denominator, "}")
} else {
paste0("\\frac{", numerator, "}{", denominator, "}")
}
}
}
frac2latex(fractions(0.5))
frac2latex(fractions(0.5), double = TRUE)
